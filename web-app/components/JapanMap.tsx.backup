'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { Resort, REGIONS } from '@/data/resorts';
import confetti from 'canvas-confetti';
import { AnimatePresence, motion } from 'framer-motion';
import { JapanBaseMap } from './JapanBaseMap';

interface JapanMapProps {
    visitedResortIds: string[];
    onResortClick: (resortId: string) => void;
    resorts: Resort[];
    externalFocusedResortId?: string | null;
    onFocusChange?: (resortId: string | null) => void;
}

export function JapanMap({
    visitedResortIds,
    onResortClick,
    resorts,
    externalFocusedResortId,
    onFocusChange
}: JapanMapProps) {
    const [hoveredResort, setHoveredResort] = useState<string | null>(null);
    const [focusedResort, setFocusedResort] = useState<Resort | null>(null);
    const mapContainerRef = useRef<HTMLDivElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const isDrawingRef = useRef(false);
    const scratchedResortsRef = useRef<Set<string>>(new Set());


    // Moved from bottom to fix scope issues
    const containerRef = useRef<HTMLDivElement>(null);
    const transformRef = useRef({ scale: 1, x: 0, y: 0 });
    const lastTouchRef = useRef<{ x: number; y: number } | null>(null);
    const initialPinchDistance = useRef<number | null>(null);
    const isDraggingRef = useRef(false);
    const modeRef = useRef<'idle' | 'pan' | 'zoom' | 'scratch'>('idle');

    // åœ°åœ–å·²é€é JapanBaseMap çµ„ä»¶è¼‰å…¥,ä¸å†éœ€è¦æ‰‹å‹• fetch

    // è¼‰å…¥åº•åœ– & é‡ç½®åˆ®åˆ®æ¨‚
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !focusedResort) return;

        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) return;

        // Linus Principle: Keep it simple. 
        // çµ±ä¸€ä½¿ç”¨ 1000x1000 çš„é‚è¼¯åæ¨™ç³»ï¼Œèˆ‡ SVG åœ°åœ–ä¿æŒä¸€è‡´ã€‚
        // é€™æ¨£ç„¡è«–è¢å¹•å°ºå¯¸æˆ–ç¸®æ”¾æ¯”ä¾‹å¦‚ä½•ï¼Œåæ¨™è¨ˆç®—éƒ½åªéœ€åœ¨ 0-1000 ç¯„åœå…§é€²è¡Œã€‚
        const LOGICAL_SIZE = 1000;
        const dpr = window.devicePixelRatio || 1;

        // è¨­ç½®ç‰©ç†åƒç´ å°ºå¯¸ (ä¿è­‰æ¸…æ™°åº¦)
        canvas.width = LOGICAL_SIZE * dpr;
        canvas.height = LOGICAL_SIZE * dpr;

        // ç¸®æ”¾ Context ä»¥åŒ¹é…é‚è¼¯åæ¨™ç³»
        ctx.scale(dpr, dpr);

        // ä½¿ç”¨ requestAnimationFrame ç¢ºä¿ Canvas å·²æº–å‚™å¥½
        requestAnimationFrame(() => {
            // ç¹ªè£½é«˜å°æ¯”åˆ®åˆ®æ¨‚é®ç½©ï¼ˆéŠ€ç°è‰²é‡‘å±¬è³ªæ„Ÿï¼‰
            const gradient = ctx.createRadialGradient(
                LOGICAL_SIZE / 2, LOGICAL_SIZE / 2, 0,
                LOGICAL_SIZE / 2, LOGICAL_SIZE / 2, LOGICAL_SIZE / 2
            );
            gradient.addColorStop(0, 'rgba(180, 180, 180, 0.95)');
            gradient.addColorStop(0.5, 'rgba(140, 140, 140, 0.98)');
            gradient.addColorStop(1, 'rgba(100, 100, 100, 0.95)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);

            // æ·»åŠ é‡‘å±¬å…‰æ¾¤
            ctx.globalAlpha = 0.3;
            const shimmer = ctx.createLinearGradient(0, 0, LOGICAL_SIZE, 0);
            shimmer.addColorStop(0, 'rgba(255, 255, 255, 0)');
            shimmer.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            shimmer.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = shimmer;
            ctx.fillRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
            ctx.globalAlpha = 1;

            // å¦‚æœå·²ç¶“è¨ªå•éï¼Œç›´æ¥å…¨é€æ˜
            if (visitedResortIds.includes(focusedResort.id)) {
                ctx.clearRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);
            }
        });
    }, [focusedResort, visitedResortIds]);



    // éŸ¿æ‡‰å¤–éƒ¨èšç„¦ & é»æ“Šé›ªå ´æ¨™è¨˜ - ä½¿ç”¨ CSS Transform æ”¾å¤§ä¸¦å±…ä¸­
    const focusAndScratch = useCallback((resort: Resort) => {
        setFocusedResort(resort);
        scratchProgressRef.current = 0;

        const container = containerRef.current;
        if (container && container.parentElement) {
            // è‡ªå‹•ç¸®æ”¾æ™‚ï¼Œå•Ÿç”¨ transition
            container.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';

            const wrapper = container.parentElement;
            const rect = wrapper.getBoundingClientRect();

            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            const mapSize = rect.width;
            const resortX = (resort.position.x / 1000) * mapSize;
            const resortY = (resort.position.y / 1000) * mapSize;

            const targetScale = 2.5;

            const targetX = centerX - resortX * targetScale;
            const targetY = centerY - resortY * targetScale;

            transformRef.current = {
                scale: targetScale,
                x: targetX,
                y: targetY
            };

            container.style.transformOrigin = '0 0';
            container.style.transform = `translate(${targetX}px, ${targetY}px) scale(${targetScale})`;
        }

        setTimeout(() => {
            if (focusedResort && !scratchedResortsRef.current.has(focusedResort.id)) {
                // setFocusedResort(null); 
            }
        }, 10000);
    }, [focusedResort]);

    // ... (ä¸­é–“ä»£ç¢¼çœç•¥) ...



    // ç”Ÿæˆç²—ç³™ç­†åˆ·ç´‹ç†
    const createBrushTexture = () => {
        const size = 64;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        if (!ctx) return canvas;

        const center = size / 2;
        const radius = size / 2;

        // ç¹ªè£½å¤šå€‹éš¨æ©Ÿå™ªé»åœ“å½¢ï¼Œæ¨¡æ“¬ç²—ç³™é‚Šç·£
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * radius;
            const x = center + Math.cos(angle) * r;
            const y = center + Math.sin(angle) * r;

            ctx.beginPath();
            ctx.arc(x, y, Math.random() * 4 + 2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.5 + 0.5})`; // éš¨æ©Ÿé€æ˜åº¦
            ctx.fill();
        }

        return canvas;
    };

    const brushRef = useRef<HTMLCanvasElement | null>(null);

    useEffect(() => {
        brushRef.current = createBrushTexture();
    }, []);

    const scratchProgressRef = useRef(0); // è¨˜éŒ„åˆ®é™¤é€²åº¦ï¼ˆç´¯ç©è·é›¢ï¼‰

    // æª¢æŸ¥åˆ®é–‹çš„é›ªå ´ - ä½¿ç”¨æ­¸ä¸€åŒ–åæ¨™ (0-1000)
    const checkScratchedResorts = useCallback((logicalX: number, logicalY: number) => {
        if (!focusedResort || visitedResortIds.includes(focusedResort.id)) return;

        // é›ªå ´ä½ç½®æœ¬èº«å°±æ˜¯ 0-1000 çš„åæ¨™
        const resortX = focusedResort.position.x;
        const resortY = focusedResort.position.y;

        const dist = Math.hypot(logicalX - resortX, logicalY - resortY);

        // åˆ¤å®šç¯„åœï¼šé‚è¼¯åæ¨™ç³»ä¸­çš„ 150 å–®ä½ (æ”¾å¯¬åˆ¤å®š)
        if (dist < 150) {
            const currentProgress = scratchProgressRef.current;
            scratchProgressRef.current = currentProgress + 5;

            if (scratchProgressRef.current > 400) {
                if (!scratchedResortsRef.current.has(focusedResort.id)) {
                    scratchedResortsRef.current.add(focusedResort.id);
                    onResortClick(focusedResort.id);

                    confetti({
                        particleCount: 150,
                        spread: 100,
                        origin: { x: 0.5, y: 0.5 },
                        colors: ['#22d3ee', '#fbbf24', '#f472b6', '#a78bfa'],
                        startVelocity: 50,
                        gravity: 1.2,
                    });

                    setTimeout(() => {
                        setFocusedResort(null);
                        onFocusChange?.(null);
                        // é‡ç½®è®Šæ›
                        if (containerRef.current) {
                            transformRef.current = { scale: 1, x: 0, y: 0 };
                            containerRef.current.style.transform = 'translate(0px, 0px) scale(1)';
                        }
                    }, 2500);
                }
            }
        }
    }, [focusedResort, visitedResortIds, onResortClick, onFocusChange]);

    // åˆ®é™¤å‡½æ•¸ - è¼¸å…¥è¢å¹•åæ¨™ï¼Œå…§éƒ¨è½‰æ›ç‚ºé‚è¼¯åæ¨™
    const scratch = useCallback((screenX: number, screenY: number) => {
        const canvas = canvasRef.current;
        const brush = brushRef.current;
        if (!canvas || !brush) return;

        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) return;

        const rect = canvas.getBoundingClientRect();

        // è½‰æ›ç‚ºé‚è¼¯åæ¨™ (0-1000)
        const logicalX = ((screenX - rect.left) / rect.width) * 1000;
        const logicalY = ((screenY - rect.top) / rect.height) * 1000;

        // ç­†åˆ·å¤§å°ï¼šåœ¨é‚è¼¯åæ¨™ç³»ä¸­å›ºå®šç‚º 80 å–®ä½ (åŠ å¤§ç­†åˆ·)
        const brushSize = 80;

        ctx.globalCompositeOperation = 'destination-out';
        ctx.drawImage(
            brush,
            logicalX - brushSize / 2,
            logicalY - brushSize / 2,
            brushSize,
            brushSize
        );
        ctx.globalCompositeOperation = 'source-over';

        checkScratchedResorts(logicalX, logicalY);
    }, [checkScratchedResorts]);

    // çµ±ä¸€æ‰‹å‹¢æ§åˆ¶å™¨ (The Linus Way: Single Source of Truth for Input)
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        const getDistance = (touch1: Touch, touch2: Touch) => {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        };

        const updateTransform = () => {
            const { x, y, scale } = transformRef.current;
            container.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        };

        const getLogicalPos = (screenX: number, screenY: number) => {
            const rect = container.getBoundingClientRect();
            return {
                x: (screenX - rect.left) / rect.width * 1000,
                y: (screenY - rect.top) / rect.height * 1000
            };
        };

        const handleTouchStart = (e: TouchEvent) => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                lastTouchRef.current = { x: touch.clientX, y: touch.clientY };
                isDraggingRef.current = true;

                // æ™ºèƒ½åˆ¤æ–·æ¨¡å¼ - ç°¡åŒ–é‚è¼¯ (Linus Principle)
                // å¦‚æœå·²èšç„¦ï¼Œå–®æŒ‡æ“ä½œé»˜èªç‚ºåˆ®åˆ®æ¨‚ï¼Œä¸å†é€²è¡Œè·é›¢åˆ¤æ–·ï¼Œç¢ºä¿"ä¸€å®šèƒ½åˆ®"
                // å¦‚æœç”¨æˆ¶æƒ³ç§»å‹•åœ°åœ–ï¼Œå¯ä»¥ä½¿ç”¨é›™æŒ‡ (Zoom/Pan)
                if (focusedResort) {
                    modeRef.current = 'scratch';
                } else {
                    modeRef.current = 'pan';
                }
            } else if (e.touches.length === 2) {
                e.preventDefault();
                initialPinchDistance.current = getDistance(e.touches[0], e.touches[1]);
                isDraggingRef.current = true;
                modeRef.current = 'zoom';
            }
        };

        const handleTouchMove = (e: TouchEvent) => {
            if (!isDraggingRef.current) return;
            e.preventDefault(); // é˜»æ­¢ç€è¦½å™¨é»˜èªè¡Œç‚º

            if (e.touches.length === 1 && lastTouchRef.current) {
                const touch = e.touches[0];

                if (modeRef.current === 'scratch') {
                    scratch(touch.clientX, touch.clientY);
                } else if (modeRef.current === 'pan') {
                    const dx = touch.clientX - lastTouchRef.current.x;
                    const dy = touch.clientY - lastTouchRef.current.y;

                    // æ‡‰ç”¨æ–°çš„ä½ç§»
                    let newX = transformRef.current.x + dx;
                    let newY = transformRef.current.y + dy;

                    // é‚Šç•Œé™åˆ¶ (Linus Principle: Don't let it fly away)
                    // å…è¨±åœ°åœ–é‚Šç·£æ‹–åˆ°å±å¹•ä¸­å¿ƒï¼Œä½†ä¸å…è¨±å®Œå…¨æ‹–å‡º
                    const rect = container.getBoundingClientRect();
                    const limitX = rect.width * 0.8;
                    const limitY = rect.height * 0.8;

                    // ç°¡å–®çš„è»Ÿé™åˆ¶
                    if (newX > limitX) newX = limitX;
                    if (newX < -limitX) newX = -limitX;
                    if (newY > limitY) newY = limitY;
                    if (newY < -limitY) newY = -limitY;

                    transformRef.current.x = newX;
                    transformRef.current.y = newY;
                    updateTransform();
                }

                lastTouchRef.current = { x: touch.clientX, y: touch.clientY };

            } else if (e.touches.length === 2 && initialPinchDistance.current) {
                // Zoom Mode - ä»¥é›™æŒ‡ä¸­å¿ƒç‚ºåŸºæº–ç¸®æ”¾
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const scaleChange = currentDistance / initialPinchDistance.current;

                const oldScale = transformRef.current.scale;
                const newScale = Math.min(Math.max(oldScale * scaleChange, 0.5), 4);

                // è¨ˆç®—é›™æŒ‡ä¸­å¿ƒé» (ç›¸å°æ–¼è¦–å£)
                const centerScreenX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerScreenY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                // ç²å–å®¹å™¨çˆ¶å…ƒç´ çš„ rect (ä½œç‚ºåƒè€ƒç³»)
                const parentRect = container.parentElement?.getBoundingClientRect();
                if (parentRect) {
                    const relativeCenterX = centerScreenX - parentRect.left;
                    const relativeCenterY = centerScreenY - parentRect.top;

                    const oldX = transformRef.current.x;
                    const oldY = transformRef.current.y;

                    // è¨ˆç®—ä¸­å¿ƒé»åœ¨é‚è¼¯ç©ºé–“(æœªç¸®æ”¾ä½ç§»å‰)çš„ä½ç½®
                    // currentPos = oldX + logicalPos * oldScale
                    // => logicalPos = (currentPos - oldX) / oldScale
                    const logicalCenterX = (relativeCenterX - oldX) / oldScale;
                    const logicalCenterY = (relativeCenterY - oldY) / oldScale;

                    // è¨ˆç®—æ–°çš„ä½ç§»ï¼Œä¿æŒä¸­å¿ƒé»ä¸å‹•
                    // newPos = relativeCenter - logicalPos * newScale
                    const newX = relativeCenterX - logicalCenterX * newScale;
                    const newY = relativeCenterY - logicalCenterY * newScale;

                    transformRef.current = {
                        scale: newScale,
                        x: newX,
                        y: newY
                    };
                } else {
                    // Fallback if parent not found (should rarely happen)
                    transformRef.current.scale = newScale;
                }

                initialPinchDistance.current = currentDistance;
                updateTransform();
            }
        };

        const handleTouchEnd = (e: TouchEvent) => {
            if (e.touches.length < 2) {
                initialPinchDistance.current = null;
            }
            if (e.touches.length === 0) {
                isDraggingRef.current = false;
                lastTouchRef.current = null;
                modeRef.current = 'idle';
            }
        };

        // Mouse Event Handlers
        const handleMouseDown = (e: MouseEvent) => {
            lastTouchRef.current = { x: e.clientX, y: e.clientY };
            isDraggingRef.current = true;

            if (focusedResort) {
                const { x, y } = getLogicalPos(e.clientX, e.clientY);
                const dist = Math.hypot(x - focusedResort.position.x, y - focusedResort.position.y);
                if (dist < 300) {
                    modeRef.current = 'scratch';
                } else {
                    modeRef.current = 'pan';
                }
            } else {
                modeRef.current = 'pan';
            }
        };

        const handleMouseMove = (e: MouseEvent) => {
            if (!isDraggingRef.current) return;
            e.preventDefault();

            if (modeRef.current === 'scratch') {
                scratch(e.clientX, e.clientY);
            } else if (modeRef.current === 'pan' && lastTouchRef.current) {
                const dx = e.clientX - lastTouchRef.current.x;
                const dy = e.clientY - lastTouchRef.current.y;
                transformRef.current.x += dx;
                transformRef.current.y += dy;
                updateTransform();
            }
            lastTouchRef.current = { x: e.clientX, y: e.clientY };
        };

        const handleMouseUp = () => {
            isDraggingRef.current = false;
            lastTouchRef.current = null;
            modeRef.current = 'idle';
        };

        // ä½¿ç”¨ passive: false ä»¥ä¾¿èƒ½ preventDefault
        container.addEventListener('touchstart', handleTouchStart, { passive: false });
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchend', handleTouchEnd);

        // Mouse events
        container.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove); // Attach to window for smooth dragging outside container
        window.addEventListener('mouseup', handleMouseUp);

        return () => {
            container.removeEventListener('touchstart', handleTouchStart);
            container.removeEventListener('touchmove', handleTouchMove);
            container.removeEventListener('touchend', handleTouchEnd);

            container.removeEventListener('mousedown', handleMouseDown);
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [focusedResort, scratch]);





    // å¤–éƒ¨èšç„¦è«‹æ±‚
    useEffect(() => {
        if (externalFocusedResortId) {
            const resort = resorts.find(r => r.id === externalFocusedResortId);
            if (resort) {
                focusAndScratch(resort);
            }
        }
    }, [externalFocusedResortId, resorts, focusAndScratch]);







    // Helper to get region color from prefecture code
    const getRegionColor = (code: number) => {
        const region = Object.values(REGIONS).find(r => r.prefectureCode.includes(code));
        return region ? region.color : '#EEEEEE';
    };

    // é‡ç½®åœ°åœ–è¦–è§’
    const resetMap = useCallback(() => {
        setFocusedResort(null);
        onFocusChange?.(null);
        if (containerRef.current) {
            // ä½¿ç”¨ transition è®“é‡ç½®éç¨‹å¹³æ»‘
            containerRef.current.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1)';
            transformRef.current = { scale: 1, x: 0, y: 0 };
            containerRef.current.style.transform = 'translate(0px, 0px) scale(1)';

            // é‡ç½®å¾Œç§»é™¤ transition ä»¥å…å½±éŸ¿æ‹–æ‹½æ€§èƒ½
            setTimeout(() => {
                if (containerRef.current) {
                    containerRef.current.style.transition = '';
                }
            }, 500);
        }
    }, [onFocusChange]);



    return (
        <div className="relative w-full h-full bg-slate-900 overflow-hidden select-none flex items-center justify-center" style={{ touchAction: 'auto' }}>
            {/* å¯ç¸®æ”¾å®¹å™¨ - å¼·åˆ¶æ­£æ–¹å½¢ä»¥ç¢ºä¿åº§æ¨™å°é½Š */}
            <div
                ref={containerRef}
                className="relative aspect-square w-full max-w-full max-h-full will-change-transform"
                style={{ touchAction: 'auto', transformOrigin: '0 0' }}
            >
                {/* å½©è‰²åº•åœ– - ä½¿ç”¨ SVG çµ„ä»¶ */}
                <div ref={mapContainerRef} className="absolute inset-0 w-full h-full transition-all duration-700 drop-shadow-2xl opacity-90">
                    <JapanBaseMap getRegionColor={getRegionColor} />
                </div>

                {/* éš±è—çå‹µå±¤ - åˆ®é–‹å¾Œé¡¯ç¤ºçš„ç²¾ç¾é€šè¡Œè­‰ (z-40) */}
                {focusedResort && (
                    <svg
                        className="absolute inset-0 w-full h-full pointer-events-none z-40"
                        viewBox="0 0 1000 1000"
                        preserveAspectRatio="xMidYMid meet"
                    >
                        <g transform={`translate(${focusedResort.position.x}, ${focusedResort.position.y})`}>
                            {/* é€šè¡Œè­‰å¡ç‰‡èƒŒæ™¯ */}
                            <rect
                                x="-60"
                                y="-40"
                                width="120"
                                height="80"
                                rx="8"
                                fill={REGIONS[focusedResort.region].color}
                                stroke="white"
                                strokeWidth="3"
                                filter="drop-shadow(0 4px 6px rgba(0,0,0,0.3))"
                            />
                            {/* è£é£¾æ€§ç´‹ç† */}
                            <path
                                d="M-60 20 L60 20"
                                stroke="rgba(255,255,255,0.3)"
                                strokeWidth="40"
                                strokeDasharray="4 4"
                            />
                            {/* é›ªå ´åç¨± */}
                            <text
                                x="0"
                                y="-10"
                                textAnchor="middle"
                                fill="white"
                                fontSize="14"
                                fontWeight="bold"
                                style={{ textShadow: '0 1px 2px rgba(0,0,0,0.5)' }}
                            >
                                {focusedResort.name}
                            </text>
                            {/* å€åŸŸ/ç¸£å¸‚ */}
                            <text
                                x="0"
                                y="10"
                                textAnchor="middle"
                                fill="rgba(255,255,255,0.9)"
                                fontSize="8"
                            >
                                {focusedResort.prefecture} | JPN
                            </text>
                            {/* é›ªå±±åœ–æ¨™ */}
                            <text
                                x="0"
                                y="30"
                                textAnchor="middle"
                                fontSize="16"
                            >
                                ğŸ”ï¸
                            </text>
                            {/* è™›æ“¬æ¢ç¢¼ */}
                            <rect x="-50" y="35" width="100" height="4" fill="rgba(255,255,255,0.5)" />
                        </g>
                    </svg>
                )}

                {/* Canvas åˆ®é™¤å±¤ - çµ•å°æœ€ä¸Šå±¤äº¤äº’ï¼Œç¦æ­¢æ‰€æœ‰ç€è¦½å™¨é»˜èªæ‰‹å‹¢ */}
                {focusedResort && (
                    <canvas
                        ref={canvasRef}
                        className="absolute inset-0 w-full h-full cursor-crosshair transition-all duration-300 z-50"
                        style={{
                            touchAction: 'none', // é—œéµï¼šå®Œå…¨ç¦æ­¢ç€è¦½å™¨è™•ç†æ‰‹å‹¢ï¼Œç¢ºä¿ 100% äº¤çµ¦ JS è™•ç†åˆ®é™¤
                        }}
                    />
                )}

                {/* SVG åœ°åœ–å±¤ (z-30) - åŒ…å«åœ°åœ–è¼ªå»“å’Œé›ªå ´æ¨™è¨˜ */}
                <svg
                    className="absolute inset-0 w-full h-full z-30"
                    viewBox="0 0 1000 1000"
                    preserveAspectRatio="xMidYMid meet"
                >
                    {/* åœ°åœ–è¼ªå»“å·²ç§»è‡³åº•å±¤ JapanBaseMap */}

                    {/* é›ªå ´æ¨™è¨˜ */}
                    {resorts.map(resort => {
                        const isFocused = focusedResort?.id === resort.id;
                        const isVisited = visitedResortIds.includes(resort.id);
                        const isHovered = hoveredResort === resort.id;
                        const color = REGIONS[resort.region].color;

                        return (
                            <g key={resort.id}>
                                {/* è„ˆè¡å…‰ç’° */}
                                {isVisited && !isFocused && (
                                    <motion.circle
                                        cx={resort.position.x}
                                        cy={resort.position.y}
                                        fill="none"
                                        stroke={color}
                                        strokeWidth={2}
                                        initial={{ r: 12, opacity: 0.8 }}
                                        animate={{ r: [12, 25, 12], opacity: [0.8, 0, 0.8] }}
                                        transition={{ duration: 2.5, repeat: Infinity, ease: 'easeInOut' }}
                                    />
                                )}

                                {/* é›ªå ´æ¨™è¨˜é» - æ”¹ç‚ºå°é›ªå±±åœ–ç¤º */}
                                <motion.g
                                    transform={`translate(${resort.position.x}, ${resort.position.y})`}
                                    className={`cursor-pointer ${focusedResort ? 'pointer-events-none' : 'pointer-events-auto'}`}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        focusAndScratch(resort);
                                    }}
                                    onMouseEnter={() => setHoveredResort(resort.id)}
                                    onMouseLeave={() => setHoveredResort(null)}
                                    whileHover={{ scale: 1.2 }}
                                    whileTap={{ scale: 0.9 }}
                                    animate={isFocused ? { scale: 1.5 } : {}}
                                >
                                    {/* é€æ˜é»æ“Šç†±å€ (åŠå¾‘ 30px) */}
                                    <circle r="30" fill="transparent" />

                                    {/* é™°å½± */}
                                    <ellipse cx="0" cy="12" rx="12" ry="4" fill="rgba(0,0,0,0.3)" />

                                    {/* é›ªå±±åœ–æ¨™ */}
                                    <g transform="translate(-12, -12) scale(0.8)">
                                        {/* å±±é«” */}
                                        <path
                                            d="M15 2 L28 25 L2 25 Z"
                                            fill={isVisited ? color : '#64748b'} // å·²è¨ªå•é¡¯ç¤ºå€åŸŸè‰²ï¼Œæœªè¨ªå•é¡¯ç¤ºç°è‰²
                                            stroke="white"
                                            strokeWidth="2"
                                            strokeLinejoin="round"
                                        />
                                        {/* å±±é ‚ç©é›ª */}
                                        <path
                                            d="M15 2 L19 9 L15 7 L11 9 Z"
                                            fill="white"
                                        />
                                    </g>

                                    {/* æ¨™ç±¤ (Hover æˆ– Focus æ™‚é¡¯ç¤º) */}
                                    {(isHovered || isFocused) && (
                                        <g transform="translate(0, -25)">
                                            <rect
                                                x="-50"
                                                y="-20"
                                                width="100"
                                                height="20"
                                                rx="10"
                                                fill="rgba(15, 23, 42, 0.9)"
                                                stroke={color}
                                                strokeWidth="2"
                                            />
                                            <text
                                                x="0"
                                                y="-6"
                                                textAnchor="middle"
                                                fill="white"
                                                fontSize="10"
                                                fontWeight="bold"
                                            >
                                                {resort.name}
                                            </text>
                                            {/* ä¸‹æ–¹å°ä¸‰è§’ */}
                                            <path d="M-5 -1 L0 4 L5 -1 Z" fill={color} />
                                        </g>
                                    )}
                                </motion.g>
                                {!isVisited && (
                                    <text
                                        x={resort.position.x + 95}
                                        y={resort.position.y + 18}
                                        textAnchor="middle"
                                        fill={color}
                                        fontSize="11"
                                        fontWeight="600"
                                    >
                                        åˆ®é–‹æˆ–é»æ“Š âœ¨
                                    </text>
                                )}
                            </g>
                        );
                    })}
                </svg>
            </div>

            {/* èšç„¦æç¤º - å›ºå®šåœ¨è¢å¹•ä¸Šï¼Œä¸éš¨åœ°åœ–ç¸®æ”¾ */}
            <AnimatePresence>
                {focusedResort && !visitedResortIds.includes(focusedResort.id) && (
                    <svg
                        className="absolute inset-0 w-full h-full pointer-events-none z-[60]"
                        viewBox="0 0 1000 1000"
                        preserveAspectRatio="xMidYMid meet"
                    >
                        {/* è„ˆè¡åœˆ - æ›´ç²—æ›´æ˜é¡¯ */}
                        <motion.circle
                            cx={focusedResort.position.x}
                            cy={focusedResort.position.y}
                            fill="none"
                            stroke="#22d3ee"
                            strokeWidth={8}
                            strokeDasharray="20 10"
                            initial={{ r: 70, opacity: 1 }}
                            animate={{
                                r: [70, 120, 70],
                                opacity: [1, 0.3, 1]
                            }}
                            transition={{
                                duration: 1.5,
                                repeat: Infinity,
                            }}
                        />

                        {/* é–ƒçˆä¸­å¿ƒå€åŸŸ */}
                        <motion.circle
                            cx={focusedResort.position.x}
                            cy={focusedResort.position.y}
                            fill="rgba(251, 191, 36, 0.3)"
                            initial={{ r: 50 }}
                            animate={{
                                r: [50, 90, 50],
                                opacity: [0.5, 0, 0.5]
                            }}
                            transition={{
                                duration: 1,
                                repeat: Infinity,
                            }}
                        />

                        {/* å¤§å­—æç¤ºæ¡† - é›ªå ´ä¸Šæ–¹ */}
                        <motion.g
                            initial={{ opacity: 0, scale: 0.8 }}
                            animate={{ opacity: 1, scale: 1 }}
                            transition={{ delay: 0.2 }}
                        >
                            {/* èƒŒæ™¯ */}
                            <rect
                                x={focusedResort.position.x - 120}
                                y={focusedResort.position.y - 170}
                                width={240}
                                height={90}
                                rx={20}
                                fill="rgba(15, 23, 42, 0.98)"
                                stroke="#fbbf24"
                                strokeWidth={4}
                                filter="drop-shadow(0 10px 40px rgba(0,0,0,0.7))"
                            />

                            {/* é›ªå ´å */}
                            <text
                                x={focusedResort.position.x}
                                y={focusedResort.position.y - 135}
                                textAnchor="middle"
                                fill="#22d3ee"
                                fontSize="28"
                                fontWeight="700"
                            >
                                {focusedResort.name}
                            </text>

                            {/* æ“ä½œæŒ‡ç¤º - é–ƒçˆ */}
                            <motion.text
                                x={focusedResort.position.x}
                                y={focusedResort.position.y - 100}
                                textAnchor="middle"
                                fill="#fbbf24"
                                fontSize="22"
                                fontWeight="700"
                                animate={{ opacity: [1, 0.3, 1] }}
                                transition={{ duration: 1, repeat: Infinity }}
                            >
                                ğŸ‘‡ æ»‘å‹•åˆ®é–‹
                            </motion.text>
                        </motion.g>

                        {/* å‘ä¸‹ç®­é ­å‹•ç•« */}
                        <motion.polygon
                            points={`${focusedResort.position.x},${focusedResort.position.y - 60} 
                         ${focusedResort.position.x - 20},${focusedResort.position.y - 80}
                         ${focusedResort.position.x - 8},${focusedResort.position.y - 80}
                         ${focusedResort.position.x - 8},${focusedResort.position.y - 95}
                         ${focusedResort.position.x + 8},${focusedResort.position.y - 95}
                         ${focusedResort.position.x + 8},${focusedResort.position.y - 80}
                         ${focusedResort.position.x + 20},${focusedResort.position.y - 80}`}
                            fill="#fbbf24"
                            stroke="#fff"
                            strokeWidth={3}
                            filter="drop-shadow(0 4px 8px rgba(0,0,0,0.5))"
                            animate={{ y: [0, 15, 0] }}
                            transition={{ duration: 1.2, repeat: Infinity, ease: 'easeInOut' }}
                        />
                    </svg>
                )}
            </AnimatePresence>
            {/* é‡ç½®è¦–è§’æŒ‰éˆ• - ç¸½æ˜¯é¡¯ç¤ºï¼Œæ–¹ä¾¿ç”¨æˆ¶è¿·è·¯æ™‚è‡ªæ•‘ */}
            <button
                onClick={(e) => {
                    e.stopPropagation();
                    resetMap();
                }}
                className="absolute bottom-6 right-6 z-[70] p-3 bg-slate-800/90 text-white rounded-full shadow-lg border border-slate-600 backdrop-blur-sm active:scale-90 transition-all hover:bg-slate-700"
                aria-label="é‡ç½®åœ°åœ–"
            >
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74-2.74L3 12" />
                    <path d="M3 3v9h9" />
                </svg>
            </button>
        </div>
    );
}
